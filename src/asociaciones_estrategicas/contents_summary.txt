

Directory: .
-------------

File: __init__.py
Path: ./__init__.py

Contents:

==================================================


Directory: config
------------------

File: uow.py
Path: ./config/uow.py

Contents:
from asociaciones_estrategicas.config.db import db
from asociaciones_estrategicas.seedwork.infraestructura.uow import UnidadTrabajo, Batch
from pydispatch import dispatcher

import logging
import traceback

class ExcepcionUoW(Exception):
    ...

class UnidadTrabajoSQLAlchemy(UnidadTrabajo):

    def __init__(self):
        self._batches: list[Batch] = list()

    def __enter__(self) -> UnidadTrabajo:
        return super().__enter__()

    def __exit__(self, *args):
        self.rollback()

    def _limpiar_batches(self):
        self._batches = list()

    @property
    def savepoints(self) -> list:
        # TODO Lea savepoint
        return []

    @property
    def batches(self) -> list[Batch]:
        return self._batches             

    def commit(self):
        for batch in self.batches:
            lock = batch.lock
            batch.operacion(*batch.args, **batch.kwargs)
                
        db.session.commit() # Commits the transaction

        super().commit()

    def rollback(self, savepoint=None):
        if savepoint:
            savepoint.rollback()
        else:
            db.session.rollback()
        
        super().rollback()
    
    def savepoint(self):
        # TODO Con MySQL y Postgres se debe usar el with para tener la lógica del savepoint
        # Piense como podría lograr esto ¿tal vez teniendo una lista de savepoints y momentos en el tiempo?
        ...

class UnidadTrabajoPulsar(UnidadTrabajo):

    def __init__(self):
        self._batches: list[Batch] = list()

    def __enter__(self) -> UnidadTrabajo:
        return super().__enter__()

    def __exit__(self, *args):
        self.rollback()

    def _limpiar_batches(self):
        self._batches = list()

    @property
    def savepoints(self) -> list:
        return []

    @property
    def batches(self) -> list[Batch]:
        return self._batches             

    def commit(self):
        index = 0
        try:
            for evento in self._obtener_eventos():
                dispatcher.send(signal=f'{type(evento).__name__}Integracion', evento=evento)
                index += 1
        except:
            logging.error('ERROR: Suscribiendose al tópico de eventos!')
            traceback.print_exc()
            self.rollback(index=index)
        self._limpiar_batches()

    def rollback(self, index=None):
        # TODO Implemente la función de rollback
        # Vea los métodos agregar_evento de la clase AgregacionRaiz
        # A cada evento que se agrega, se le asigna un evento de compensación
        # Piense como podría hacer la implementación
        
        super().rollback()
    
    def savepoint(self):
        # NOTE No hay punto de implementar este método debido a la naturaleza de Event Sourcing
        ...
==================================================

File: __init__.py
Path: ./config/__init__.py

Contents:

==================================================

File: db.py
Path: ./config/db.py

Contents:
from flask_sqlalchemy import SQLAlchemy
from flask import Flask
import os

db = None

DB_USERNAME = os.getenv('DB_USERNAME', default="root")
DB_PASSWORD = os.getenv('DB_PASSWORD', default="pwdadmin")
DB_HOSTNAME = os.getenv('DB_HOSTNAME', default="localhost")

class DatabaseConfigException(Exception):
    def __init__(self, message='Configuration file is Null or malformed'):
        self.message = message
        super().__init__(self.message)


def database_connection(config, basedir=os.path.abspath(os.path.dirname(__file__))) -> str:
    if not isinstance(config,dict):
        raise DatabaseConfigException
    
    if config.get('TESTING', False) == True:
        return f'sqlite:///{os.path.join(basedir, "database.db")}'
    else:
        return f'mysql+pymysql://{DB_USERNAME}:{DB_PASSWORD}@{DB_HOSTNAME}/asociaciones_estrategicas'


def init_db(app: Flask):
    global db
    if db is None:
        db = SQLAlchemy()
    if 'sqlalchemy' not in app.extensions:
        db.init_app(app)
==================================================


Directory: seedwork
--------------------

File: __init__.py
Path: ./seedwork/__init__.py

Contents:

==================================================


Directory: seedwork/infraestructura
------------------------------------

File: uow.py
Path: ./seedwork/infraestructura/uow.py

Contents:
from abc import ABC, abstractmethod
from enum import Enum

from aeroalpes.seedwork.dominio.entidades import AgregacionRaiz
from pydispatch import dispatcher

import pickle
import logging
import traceback


class Lock(Enum):
    OPTIMISTA = 1
    PESIMISTA = 2

class Batch:
    def __init__(self, operacion, lock: Lock, *args, **kwargs):
        self.operacion = operacion
        self.args = args
        self.lock = lock
        self.kwargs = kwargs

class UnidadTrabajo(ABC):

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.rollback()

    def _obtener_eventos_rollback(self, batches=None):
        batches = self.batches if batches is None else batches
        eventos = list()
        for batch in batches:
            for arg in batch.args:
                if isinstance(arg, AgregacionRaiz):
                    eventos += arg.eventos_compensacion
                    break
        return eventos

    def _obtener_eventos(self, batches=None):
        batches = self.batches if batches is None else batches
        eventos = list()
        for batch in batches:
            for arg in batch.args:
                if isinstance(arg, AgregacionRaiz):
                    eventos += arg.eventos
                    break
        return eventos

    @abstractmethod
    def _limpiar_batches(self):
        raise NotImplementedError

    @abstractmethod
    def batches(self) -> list[Batch]:
        raise NotImplementedError

    @abstractmethod
    def savepoints(self) -> list:
        raise NotImplementedError                    

    def commit(self):
        self._publicar_eventos_post_commit()
        self._limpiar_batches()

    @abstractmethod
    def rollback(self, savepoint=None):
        self._limpiar_batches()
    
    @abstractmethod
    def savepoint(self):
        raise NotImplementedError

    def registrar_batch(self, operacion, *args, lock=Lock.PESIMISTA, repositorio_eventos_func=None,**kwargs):
        batch = Batch(operacion, lock, *args, **kwargs)
        self.batches.append(batch)
        self._publicar_eventos_dominio(batch, repositorio_eventos_func)

    def _publicar_eventos_dominio(self, batch, repositorio_eventos_func):
        for evento in self._obtener_eventos(batches=[batch]):
            if repositorio_eventos_func:
                repositorio_eventos_func(evento)
            dispatcher.send(signal=f'{type(evento).__name__}Dominio', evento=evento)

    def _publicar_eventos_post_commit(self):
        try:
            for evento in self._obtener_eventos():
                dispatcher.send(signal=f'{type(evento).__name__}Integracion', evento=evento)
        except:
            logging.error('ERROR: Suscribiendose al tópico de eventos!')
            traceback.print_exc()
            

def is_flask():
    try:
        from flask import session
        return True
    except Exception as e:
        return False

def registrar_unidad_de_trabajo(serialized_obj):
    from aeroalpes.config.uow import UnidadTrabajoSQLAlchemy
    from flask import session
    

    session['uow'] = serialized_obj

def flask_uow():
    from flask import session
    from aeroalpes.config.uow import UnidadTrabajoSQLAlchemy, UnidadTrabajoPulsar
    if session.get('uow'):
        return session['uow']

    uow_serialized = pickle.dumps(UnidadTrabajoSQLAlchemy())
    if session.get('uow_metodo') == 'pulsar':
        uow_serialized = pickle.dumps(UnidadTrabajoPulsar())
    
    registrar_unidad_de_trabajo(uow_serialized)
    return uow_serialized

def unidad_de_trabajo() -> UnidadTrabajo:
    if is_flask():
        return pickle.loads(flask_uow())
    else:
        raise Exception('No hay unidad de trabajo')

def guardar_unidad_trabajo(uow: UnidadTrabajo):
    if is_flask():
        registrar_unidad_de_trabajo(pickle.dumps(uow))
    else:
        raise Exception('No hay unidad de trabajo')


class UnidadTrabajoPuerto:

    @staticmethod
    def commit():
        uow = unidad_de_trabajo()
        uow.commit()
        guardar_unidad_trabajo(uow)

    @staticmethod
    def rollback(savepoint=None):
        uow = unidad_de_trabajo()
        uow.rollback(savepoint=savepoint)
        guardar_unidad_trabajo(uow)

    @staticmethod
    def savepoint():
        uow = unidad_de_trabajo()
        uow.savepoint()
        guardar_unidad_trabajo(uow)

    @staticmethod
    def dar_savepoints():
        uow = unidad_de_trabajo()
        return uow.savepoints()

    @staticmethod
    def registrar_batch(operacion, *args, lock=Lock.PESIMISTA, **kwargs):
        uow = unidad_de_trabajo()
        uow.registrar_batch(operacion, *args, lock=lock, **kwargs)
        guardar_unidad_trabajo(uow)

==================================================

File: utils.py
Path: ./seedwork/infraestructura/utils.py

Contents:
import time
import os
import datetime

epoch = datetime.datetime.utcfromtimestamp(0)

def time_millis():
    return int(time.time() * 1000)

def unix_time_millis(dt):
    return (dt - epoch).total_seconds() * 1000.0

def millis_a_datetime(millis):
    return datetime.datetime.fromtimestamp(millis/1000.0)

def broker_host():
    return os.getenv('BROKER_HOST', default="localhost")


==================================================

File: vistas.py
Path: ./seedwork/infraestructura/vistas.py

Contents:
from abc import ABC, abstractmethod

class Vista(ABC):

    @abstractmethod
    def obtener_por(**kwargs):
        ...
==================================================

File: __init__.py
Path: ./seedwork/infraestructura/__init__.py

Contents:

==================================================

File: proyecciones.py
Path: ./seedwork/infraestructura/proyecciones.py

Contents:
from functools import singledispatch
from abc import ABC, abstractmethod

class Proyeccion(ABC):
    @abstractmethod
    def ejecutar(self):
        ...

class ProyeccionHandler(ABC):
    @abstractmethod
    def handle(self, proyeccion: Proyeccion):
        ...

@singledispatch
def ejecutar_proyeccion(proyeccion):
    raise NotImplementedError(f'No existe implementación para la proyección de tipo {type(proyeccion).__name__}')
==================================================


Directory: seedwork/infraestructura/schema
-------------------------------------------

File: __init__.py
Path: ./seedwork/infraestructura/schema/__init__.py

Contents:

==================================================


Directory: seedwork/infraestructura/schema/v1
----------------------------------------------

File: eventos.py
Path: ./seedwork/infraestructura/schema/v1/eventos.py

Contents:
from .mensajes import Mensaje

class EventoIntegracion(Mensaje):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
==================================================

File: mensajes.py
Path: ./seedwork/infraestructura/schema/v1/mensajes.py

Contents:
import uuid

from pulsar.schema import *
from aeroalpes.seedwork.infraestructura.utils import time_millis

class Mensaje(Record):
    id = String(default=str(uuid.uuid4()))
    time = Long()
    ingestion = Long(default=time_millis())
    specversion = String()
    type = String()
    datacontenttype = String()
    service_name = String()

    def __init__(self, *args, id=None, **kwargs):
        super().__init__(*args, id=id, **kwargs)
==================================================

File: comandos.py
Path: ./seedwork/infraestructura/schema/v1/comandos.py

Contents:
from .mensajes import Mensaje

class ComandoIntegracion(Mensaje):
    ...
==================================================

File: __init__.py
Path: ./seedwork/infraestructura/schema/v1/__init__.py

Contents:

==================================================


Directory: seedwork/dominio
----------------------------

File: eventos.py
Path: ./seedwork/dominio/eventos.py

Contents:
"""Entidades reusables parte del seedwork del proyecto

En este archivo usted encontrará las clases para eventos reusables parte del seedwork del proyecto

"""

from dataclasses import dataclass, field
from .reglas import IdEntidadEsInmutable
from .excepciones import IdDebeSerInmutableExcepcion
from datetime import datetime
import uuid

@dataclass
class EventoDominio():
    id: uuid.UUID = field(hash=True)
    _id: uuid.UUID = field(init=False, repr=False, hash=True)
    fecha_evento: datetime =  field(default=datetime.now())


    @classmethod
    def siguiente_id(self) -> uuid.UUID:
        return uuid.uuid4()

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, id: uuid.UUID) -> None:
        if not IdEntidadEsInmutable(self).es_valido():
            raise IdDebeSerInmutableExcepcion()
        self._id = self.siguiente_id()
==================================================

File: reglas.py
Path: ./seedwork/dominio/reglas.py

Contents:
"""Reglas de negocio reusables parte del seedwork del proyecto

En este archivo usted encontrará reglas de negocio reusables parte del seedwork del proyecto

"""

from abc import ABC, abstractmethod

class ReglaNegocio(ABC):

    __mensaje: str ='La regla de negocio es invalida'

    def __init__(self, mensaje):
        self.__mensaje = mensaje

    def mensaje_error(self) -> str:
        return self.__mensaje

    @abstractmethod
    def es_valido(self) -> bool:
        ...

    def __str__(self):
        return f"{self.__class__.__name__} - {self.__mensaje}"


class IdEntidadEsInmutable(ReglaNegocio):

    entidad: object

    def __init__(self, entidad, mensaje='El identificador de la entidad debe ser Inmutable'):
        super().__init__(mensaje)
        self.entidad = entidad

    def es_valido(self) -> bool:
        try:
            if self.entidad._id:
                return False
        except AttributeError as error:
            return True

==================================================

File: servicios.py
Path: ./seedwork/dominio/servicios.py

Contents:
""" Definición de interfaces de Servicios reusables parte del seedwork del proyecto

En este archivo usted encontrará las diferentes interfaces para Servicios
reusables parte del seedwork del proyecto

"""

from .mixins import ValidarReglasMixin
 
class Servicio(ValidarReglasMixin):
    ...
==================================================

File: excepciones.py
Path: ./seedwork/dominio/excepciones.py

Contents:
""" Excepciones reusables parte del seedwork del proyecto

En este archivo usted encontrará los Excepciones reusables parte del seedwork del proyecto

"""

from .reglas import ReglaNegocio

class ExcepcionDominio(Exception):
    ...

class IdDebeSerInmutableExcepcion(ExcepcionDominio):
    def __init__(self, mensaje='El identificador debe ser inmutable'):
        self.__mensaje = mensaje
    def __str__(self):
        return str(self.__mensaje)

class ReglaNegocioExcepcion(ExcepcionDominio):
    def __init__(self, regla: ReglaNegocio):
        self.regla = regla

    def __str__(self):
        return str(self.regla)

class ExcepcionFabrica(ExcepcionDominio):
    def __init__(self, mensaje):
        self.__mensaje = mensaje
    def __str__(self):
        return str(self.__mensaje)
==================================================

File: fabricas.py
Path: ./seedwork/dominio/fabricas.py

Contents:
""" Fábricas para la creación de objetos reusables parte del seedwork del proyecto

En este archivo usted encontrará las diferentes fábricas para crear
objetos complejos reusables parte del seedwork del proyecto

"""

from abc import ABC, abstractmethod
from .repositorios import Mapeador
from .mixins import ValidarReglasMixin

class Fabrica(ABC, ValidarReglasMixin):
    @abstractmethod
    def crear_objeto(self, obj: any, mapeador: Mapeador=None) -> any:
        ...
==================================================

File: repositorios.py
Path: ./seedwork/dominio/repositorios.py

Contents:
""" Interfaces para los repositorios reusables parte del seedwork del proyecto

En este archivo usted encontrará las diferentes interfaces para repositorios
reusables parte del seedwork del proyecto

"""

from abc import ABC, abstractmethod
from uuid import UUID
from .entidades import Entidad

class Repositorio(ABC):
    @abstractmethod
    def obtener_por_id(self, id: UUID) -> Entidad:
        ...

    @abstractmethod
    def obtener_todos(self) -> list[Entidad]:
        ...

    @abstractmethod
    def agregar(self, entity: Entidad):
        ...

    @abstractmethod
    def actualizar(self, entity: Entidad):
        ...

    @abstractmethod
    def eliminar(self, entity_id: UUID):
        ...


class Mapeador(ABC):
    @abstractmethod
    def obtener_tipo(self) -> type:
        ...

    @abstractmethod
    def entidad_a_dto(self, entidad: Entidad) -> any:
        ...

    @abstractmethod
    def dto_a_entidad(self, dto: any) -> Entidad:
        ...
    
==================================================

File: __init__.py
Path: ./seedwork/dominio/__init__.py

Contents:

==================================================

File: entidades.py
Path: ./seedwork/dominio/entidades.py

Contents:
"""Entidades reusables parte del seedwork del proyecto

En este archivo usted encontrará las entidades reusables parte del seedwork del proyecto

"""

from dataclasses import dataclass, field
from .eventos import EventoDominio
from .mixins import ValidarReglasMixin
from .reglas import IdEntidadEsInmutable
from .excepciones import IdDebeSerInmutableExcepcion
from datetime import datetime
import uuid

@dataclass
class Entidad:
    id: uuid.UUID = field(hash=True)
    _id: uuid.UUID = field(init=False, repr=False, hash=True)
    fecha_creacion: datetime =  field(default=datetime.now())
    fecha_actualizacion: datetime = field(default=datetime.now())

    @classmethod
    def siguiente_id(self) -> uuid.UUID:
        return uuid.uuid4()

    @property
    def id(self):
        return self._id

    @id.setter
    def id(self, id: uuid.UUID) -> None:
        if not IdEntidadEsInmutable(self).es_valido():
            raise IdDebeSerInmutableExcepcion()
        self._id = self.siguiente_id()
        

@dataclass
class AgregacionRaiz(Entidad, ValidarReglasMixin):
    eventos: list[EventoDominio] = field(default_factory=list)
    eventos_compensacion: list[EventoDominio] = field(default_factory=list)

    def agregar_evento(self, evento: EventoDominio, evento_compensacion: EventoDominio = None):
        self.eventos.append(evento)

        if evento_compensacion:
            self.eventos_compensacion.append(evento_compensacion)
    
    def limpiar_eventos(self):
        self.eventos = list()
        self.eventos_compensacion = list()


@dataclass
class Locacion(Entidad):
    def __str__(self) -> str:
        ...
==================================================

File: objetos_valor.py
Path: ./seedwork/dominio/objetos_valor.py

Contents:
"""Objetos valor reusables parte del seedwork del proyecto

En este archivo usted encontrará los objetos valor reusables parte del seedwork del proyecto

"""

from dataclasses import dataclass
from abc import ABC, abstractmethod
from .entidades import Locacion
from datetime import datetime

@dataclass(frozen=True)
class ObjetoValor:
    ...

@dataclass(frozen=True)
class Codigo(ABC, ObjetoValor):
    codigo: str

class Ruta(ABC, ObjetoValor):
    @abstractmethod
    def origen(self) -> Locacion:
        ...
    
    @abstractmethod
    def destino(self) -> Locacion:
        ...
    
    @abstractmethod
    def fecha_salida(self) -> datetime:
        ...

    @abstractmethod
    def fecha_llegada(self) -> datetime:
        ...

@dataclass(frozen=True)
class Pais(ObjetoValor):
    codigo: Codigo
    nombre: str

@dataclass(frozen=True)
class Ciudad(ObjetoValor):
    pais: Pais
    codigo: Codigo
    nombre: str



==================================================

File: mixins.py
Path: ./seedwork/dominio/mixins.py

Contents:
"""Mixins reusables parte del seedwork del proyecto

En este archivo usted encontrará las Mixins reusables parte del seedwork del proyecto

"""

from .reglas import ReglaNegocio
from .excepciones import ReglaNegocioExcepcion

class ValidarReglasMixin:
    def validar_regla(self, regla: ReglaNegocio):
        if not regla.es_valido():
            raise ReglaNegocioExcepcion(regla)
==================================================


Directory: seedwork/aplicacion
-------------------------------

File: servicios.py
Path: ./seedwork/aplicacion/servicios.py

Contents:
class Servicio:
    ...
==================================================

File: handlers.py
Path: ./seedwork/aplicacion/handlers.py

Contents:
class Handler:
    ...
==================================================

File: comandos.py
Path: ./seedwork/aplicacion/comandos.py

Contents:
from functools import singledispatch
from abc import ABC, abstractmethod

class Comando:
    ...

class ComandoHandler(ABC):
    @abstractmethod
    def handle(self, comando: Comando):
        raise NotImplementedError()

@singledispatch
def ejecutar_commando(comando):
    raise NotImplementedError(f'No existe implementación para el comando de tipo {type(comando).__name__}')
==================================================

File: __init__.py
Path: ./seedwork/aplicacion/__init__.py

Contents:

==================================================

File: queries.py
Path: ./seedwork/aplicacion/queries.py

Contents:
from functools import singledispatch
from abc import ABC, abstractmethod
from dataclasses import dataclass


class Query(ABC):
    ...

@dataclass
class QueryResultado:
    resultado: None

class QueryHandler(ABC):
    @abstractmethod
    def handle(self, query: Query) -> QueryResultado:
        raise NotImplementedError()

@singledispatch
def ejecutar_query(query):
    raise NotImplementedError(f'No existe implementación para el query de tipo {type(query).__name__}')
==================================================

File: dto.py
Path: ./seedwork/aplicacion/dto.py

Contents:
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass(frozen=True)
class DTO():
    ...

class Mapeador(ABC):
    @abstractmethod
    def externo_a_dto(self, externo: any) -> DTO:
        ...

    @abstractmethod
    def dto_a_externo(self, dto: DTO) -> any:
        ...
    
==================================================


Directory: seedwork/presentacion
---------------------------------

File: api.py
Path: ./seedwork/presentacion/api.py

Contents:
import functools

from flask import (
    Blueprint, flash, g, redirect, render_template, request, session, url_for
)

def crear_blueprint(identificador: str, prefijo_url: str):
    return Blueprint(identificador, __name__, url_prefix=prefijo_url)
==================================================

File: __init__.py
Path: ./seedwork/presentacion/__init__.py

Contents:

==================================================


Directory: modulos
-------------------


Directory: api
---------------

File: __init__.py
Path: ./api/__init__.py

Contents:
import os

from flask import Flask, render_template, request, url_for, redirect, jsonify, session
from flask_swagger import swagger

# Identifica el directorio base
basedir = os.path.abspath(os.path.dirname(__file__))

def registrar_handlers():
    pass #TODO
    #import aeroalpes.modulos.cliente.aplicacion
    #import aeroalpes.modulos.vuelos.aplicacion
def importar_modelos_alchemy():
    pass #TODO
    #import aeroalpes.modulos.cliente.infraestructura.dto
    #import aeroalpes.modulos.hoteles.infraestructura.dto
    #import aeroalpes.modulos.pagos.infraestructura.dto
    #import aeroalpes.modulos.precios_dinamicos.infraestructura.dto
    #import aeroalpes.modulos.vehiculos.infraestructura.dto
    #import aeroalpes.modulos.vuelos.infraestructura.dto

def comenzar_consumidor(app):
    """
    Este es un código de ejemplo. Aunque esto sea funcional puede ser un poco peligroso tener 
    threads corriendo por si solos. Mi sugerencia es en estos casos usar un verdadero manejador
    de procesos y threads como Celery.
    """
    pass #TODO

    #import threading
    #import aeroalpes.modulos.cliente.infraestructura.consumidores as cliente
    #import aeroalpes.modulos.hoteles.infraestructura.consumidores as hoteles
    #import aeroalpes.modulos.pagos.infraestructura.consumidores as pagos
    #import aeroalpes.modulos.precios_dinamicos.infraestructura.consumidores as precios_dinamicos
    #import aeroalpes.modulos.vehiculos.infraestructura.consumidores as vehiculos
    #import aeroalpes.modulos.vuelos.infraestructura.consumidores as vuelos

    # Suscripción a eventos
    #threading.Thread(target=cliente.suscribirse_a_eventos).start()
    #threading.Thread(target=hoteles.suscribirse_a_eventos).start()
    #threading.Thread(target=pagos.suscribirse_a_eventos).start()
    #threading.Thread(target=precios_dinamicos.suscribirse_a_eventos).start()
    #threading.Thread(target=vehiculos.suscribirse_a_eventos).start()
    #threading.Thread(target=vuelos.suscribirse_a_eventos, args=[app]).start()

    # Suscripción a comandos
    #threading.Thread(target=cliente.suscribirse_a_comandos).start()
    #threading.Thread(target=hoteles.suscribirse_a_comandos).start()
    #threading.Thread(target=pagos.suscribirse_a_comandos).start()
    #threading.Thread(target=precios_dinamicos.suscribirse_a_comandos).start()
    #threading.Thread(target=vehiculos.suscribirse_a_comandos).start()
    #threading.Thread(target=vuelos.suscribirse_a_comandos, args=[app]).start()

def create_app(configuracion={}):
    # Init la aplicacion de Flask
    app = Flask(__name__, instance_relative_config=True)
    
    app.secret_key = '9d58f999-3ae8-4149-a09f-3a8c2012e399'
    app.config['SESSION_TYPE'] = 'filesystem'
    app.config['TESTING'] = configuracion.get('TESTING')

     # Inicializa la DB
    from asociaciones_estrategicas.config.db import init_db, database_connection

    app.config['SQLALCHEMY_DATABASE_URI'] = database_connection(configuracion, basedir=basedir)
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

    init_db(app)

    from asociaciones_estrategicas.config.db import db

    importar_modelos_alchemy()
    registrar_handlers()

    with app.app_context():
        db.create_all()
        if not app.config.get('TESTING'):
            comenzar_consumidor(app)

    # Importa Blueprints
    #from . import cliente
    #from . import hoteles
    #from . import pagos
    #from . import precios_dinamicos
    #from . import vehiculos
    #from . import vuelos

    # Registro de Blueprints
    #app.register_blueprint(cliente.bp)
    #app.register_blueprint(hoteles.bp)
    #app.register_blueprint(pagos.bp)
    #app.register_blueprint(precios_dinamicos.bp)
    #app.register_blueprint(vehiculos.bp)
    #app.register_blueprint(vuelos.bp)

    @app.route("/spec")
    def spec():
        swag = swagger(app)
        swag['info']['version'] = "1.0"
        swag['info']['title'] = "My API"
        return jsonify(swag)

    @app.route("/health")
    def health():
        return {"status": "up"}

    return app

==================================================
